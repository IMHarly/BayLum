#' @title Display Scatter Plot Matrix of the Bayesian Age Results
#'
#' @description Create a hexbin plot matrix ([hexbin::hexplom]) of age results returned by the bayesian age calculation.
#'
#' @details
#'
#' **Addtional supported plot arguments**\cr
#'
#' The following table lists additional arguments supported by the function in order to fine tune the
#' graphical output. Such arguments, can just be added in the function call. Example, for disabling
#' the [graphics::rug] in the plot mode `smoothScatter` you can type `plot_Scatterplots(..., rug = FALSE)`
#' Please note that not all arguments are supported by all plot types.
#'
#' \tabular{lll}{
#' **ARGUMENT** \tab **SUPPORTED BY PLOT TYPE** \tab **DESCRIPTION** \cr
#' `colramp` \tab `hexbin` and `smoothScatter` \tab Option to define an own colour ramp, by defining an own function, e.g., `function(n) heat.colors(n, alpha = 1)`. \cr
#' `pscales` \tab `hexbin` and `smoothScatter` \tab Controls the number of ticks shown on the plot axes, please note that the number works proportionally. \cr
#' `bw_smoothScatter` \tab `smoothScatter` \tab Controls the bandwith of the smooth scatter, cf. [graphics::smoothScatter] \cr
#' `rug` \tab `smoothScatter` \tab enables/disables rugs \cr
#' `nlevels` \tab `smoothScatter` \tab controls the number of isolines shown (cf. [graphics::contour]) \cr
#' `nrpoints` \tab `smoothScatter` \tab defines the number of `nrpoints` to be plotted [graphics::smoothScatter] \cr
#' `col_contour` \tab `smoothScatter` \tab defines the colour of the contour lines \cr
#' `col_nrpoints` \tab `smoothScatter` \tab sets colour of the nrpoints in the scatter plot
#'
#' }
#'
#'
#' @param object [coda::mcmc.list] (**required**): mcmc list objects generated by [rjags::jags.model] in [AgeS_Computation],
#' [AgeC14_Computation] or [Age_OSLC14].
#'
#' @param variables [character] (*with default*): variable to be selected for the scatter plot, e.g., `"A"`. Please note
#' that you can only select one variable at the time
#'
#' @param sample_names [character] (*optional*): sample names shown in the plot matrix
#'
#' @param sample_selection [numeric] (*with default*): vector of samples to be plotted in the scatter matrix, e.g.,
#' `c(1,2)` will plot the first two samples, `c(1,3)` will plot samples 1 and 3 and `c(1:3)` will plot the first
#' three samples
#'
#' @param n.chains [integer] (*with default*): allows to limit the number of chains shown,
#' by default the results of all chains are plotted.
#'
#' @param plot_type [character] (*with default*): switch between different plot types, `"hexbin"` (the default), based on
#' the function [hexbin::hexplom] and `smoothScatter` (the alternative) based on a highly customised plot function using the
#' function [graphics::smoothScatter]
#'
#' @param ... further arguments to control the plot output, standard plot arguments supported are `main`, `xlab`, `ylab`. For additional
#' arguments supporting a fine tuning of the plot, see details.
#'
#' @return
#' A scatter plot based on [hexbin::hexplom]
#'
#' @section Function version: 0.2.0
#'
#' @author Sebastian Kreutzer, IRAMAT-CRP2A, UMR 5060, CNRS - Université Bordeaux Montaigne (France), based on the
#' function `ScatterSamples()` by Claire Christophe, Anne Philippe, Guillaume Guérin
#'
#' @seealso [Age_Computation], [AgeS_Computation], [AgeC14_Computation],
#' and [rjags] packages.
#'
#' @examples
#' data(AgeS,envir = environment())
#'
#' ##hexbin
#' plot_Scatterplots(
#'    object = AgeS$Sampling,
#'    sample_names = c("GDB5", "GDB3"),
#'    sample_selection = c(1,2)
#'  )
#'
#' ##scatter smooth
#' plot_Scatterplots(
#'    object = AgeS$Sampling,
#'    sample_names = c("GDB5", "GDB3"),
#'    sample_selection = c(1,2),
#'    plot_type = "smoothScatter")
#'
#' @md
#' @export
plot_Scatterplots <- function(
  object,
  variables = c("A"),
  sample_names = NULL,
  sample_selection = NULL,
  n.chains = NULL,
  plot_type = "hexbin",
  ...
){


  # Verify input --------------------------------------------------------------------------------
  if (is.null(attributes(object)$class) || attributes(object)$class != "mcmc.list")
    stop("[plot_Scatterplots()] Wrong input, only objects of type 'mcmc.list' are allowed. Please check the manual!",
      call. = FALSE
    )


  # Extract wanted parameters -------------------------------------------------------------------
  if(length(variables) > 1)
    stop("[plot_Scatterplots()] You can only select one variable at the time!", call. = FALSE)


  if(!all(gsub(coda::varnames(object), pattern = "\\[.+\\]" ,replacement = "") %in% variables)){
    sel <- which(gsub(coda::varnames(object), pattern = "\\[.+\\]" ,replacement = "") %in% variables)
    if(length(sel) == 0){
      allowed <- unique(gsub(coda::varnames(object), pattern = "\\[.+\\]" ,replacement = ""))
      stop(paste0("[plot_Scatterplots()] Invalid 'variables', they did not match your dataset. Variable names of your dataset: ",
                  paste(allowed, collapse = ", "), "."), call. = FALSE)
    }

    ##create new object
    object <- as.mcmc.list(lapply(object, function(x){
      x[,sel, drop = FALSE]

    }))

  }

  # Preset values  ------------------------------------------------------------------------------
  ##get number of samples
  n.samples <- length(coda::varnames(object))

  ##set sample names
  if(is.null(sample_names)){
    sample_names <- paste0("Sample ", 1:n.samples)

  }else{
    if(length(sample_names) < n.samples){
      warning("[plot_Scatterplots()] length of 'sample_names' shorter than the number of samples; default values used!", call. = FALSE)
      sample_names <- paste0("Sample ", 1:n.samples)

    }
  }

  ##get number of chains
  if(is.null(n.chains)){
    n.chains <- coda::nchain(object)

  }else{
    if(n.chains > coda::nchain(object) || n.chains < coda::nchain(object)){
      n.chains <- coda::nchain(object)
      warning(paste0("[plot_Scatterplots()] 'n.chains' setting wrong. You have ", n.chains, " chains, reset to default."), call. = FALSE)

    }

  }

  ##make a sample selection
  if(is.null(sample_selection)){
    sample_selection <- 1:n.samples

  }else{
    if(length(sample_selection) > n.samples || length(sample_selection) < 2 || max(sample_selection) > n.samples || min(sample_selection) < 1){
      warning(paste0("[plot_Scatterplots()] You have only ", n.samples, " samples. 'sample_selection' wrong, reset to default!"), call. = FALSE)
      sample_selection <- 1:n.samples
    }

  }


  # Combine to matrix ---------------------------------------------------------------------------
  m <- do.call(rbind,object[1:n.chains])

    ##remove all columns we don't need, this makes the plot simple
    m <- m[, sample_selection ]

    ##reset sample names
    colnames(m) <- sample_names[sample_selection]



  # # Plot output ---------------------------------------------------------------------------------
  ##make sure we do not screw up the par settings
  par.default <- par(no.readonly = TRUE)
  on.exit(do.call(what = par, args = list(par.default$mfrow, par.default$cex)))

  ##set plot settings
  plot_settings <- list(
    xlab = "Age (ka)",
    ylab = "Age (ka)",
    colramp = if(plot_type == "hexbin") {
      function(n) terrain.colors(n, alpha = 1)
      } else {
        colorRampPalette(c("white", blues9))
      },
    pscales = 3,
    main = "Scatter Plots",
    bw_smoothScatter = 0.8,
    nlevels = 10,
    rug = TRUE,
    cex = 1.0,
    nrpoints = 100,
    col_nrpoints = "black",
    col_contour = "white"

  )

  ##reset list on demand
  plot_settings <- modifyList(x = plot_settings, val = list(...))

  ###++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ###hexbin scatter plot
  ###++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  ##create plot
  if(plot_type == 'hexbin'){
    hexbin::hexplom(
      x = m,
      upper.panel = NULL,
      xlab = plot_settings$xlab,
      ylab = plot_settings$ylab,
      pscales = plot_settings$pscales,
      colramp = plot_settings$colramp,
      main = plot_settings$main
    )


  }else{
    ###++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ###BayLum scatter plot function
    ###++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    ###(0) extract datasets
    ##get possible combinations of the dataset
    cmb <- combn(colnames(m), m = 2)

    ##create list of matricies with that combinations
    data_list <- lapply(1:ncol(cmb), function(x){
      return(m[,cmb[,x]])

    })

    ###(1) create plot matrix+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ###CREATE GRID MATRIX
      n <- ncol(m)
      name <- rep(sample_names,n)

      ##set prototype grid matrix with index
      m <- matrix(1:n^2, ncol = n, nrow = n, byrow = TRUE)

      ##reshuffle matrix, otherwise we get always the opposite
      m_re <- m[1:nrow(m),ncol(m):1]

      ##identify all diagonal members
      m_diag <- diag(m_re)

      ##identify upper triangle
      m_upper <- sort(m_re[upper.tri(m_re)])

      ##identify lower triangle
      m_lower <- sort(m_re[lower.tri(m_re)])

      ##get subdiagonal members, only this will have axis labelling
      m_diag_sub <- m_diag[2:length(m_diag)] + 1


    ###(2) - SET PROTOYPE FUNCTIONS+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    ##PLOT 1 - EMPTY PLOT
    empty_plot <- function(){
        plot(NA,NA,xlim = c(0,1), ylim = c(0,1), xlab = "", ylab = "", xaxt = "n", yaxt = "n")

    }

    ##PLOT 2 - NAME PLOT +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    name_plot <- function(data, name, xdens = TRUE, ydens = TRUE){
      ##define transfer function
      transfer <- function(x, max_scale){
        n <- min(x)
        m <- (max(x) - n) / max_scale
        return((x - n)/m)
      }

        ##create plot area
        plot(NA,NA,xlim = c(0,1), ylim = c(0,1), xlab = "", ylab = "", xaxt = "n", yaxt = "n")

        ##calculate density
        density1 <- density(data[,2])
        density2 <- density(data[,1])

        ##draw density polygones
        ##marginal density on the xaxis
        if(xdens){
          x <- transfer(density1$x, max_scale = 1)
          y <- transfer(density1$y, max_scale = 0.25) + par()$usr[1]

          polygon(
            x = c(x, rev(x)),
            y = c(y, rep(par()$usr[1], length(x))),
            col = rgb(0,0,0,0.1),
            border = "darkgray"
            )


        }

        ##marginal density y-axis
        if(ydens){
          x <- 1 - transfer(density2$y, max_scale = 0.25) - par()$usr[1]
          y <- transfer(density2$x, max_scale = 1)

          polygon(
            x = c(x, rev(x)),
            y = c(y, rep(par()$usr[1], length(x))),
            col = rgb(0,0,0,0.1),
            border = "darkgray"
            )

        }

        ##add sample name
        text(x = 0.5, y = 0.5, labels = name, cex = 1.5)

      }

      ##PLOT 3 - SCATTER PLOT
      scatter_plot <- function(data, xaxt = TRUE, yaxt = TRUE, xrug = TRUE, yrug = TRUE){
        smoothScatter(
          x = data[, 2],
          y = data[, 1],
          bandwidth = plot_settings$bw_smoothScatter,
          xlab = "",
          ylab = "",
          xaxt = "n",
          yaxt = "n",
          nrpoints = plot_settings$nrpoints,
          col = plot_settings$col_nrpoints,
          colramp = plot_settings$colramp
        )

        ##get information from the kernel smoother and than create contour lines
        con <- KernSmooth::bkde2D(x = data[,c(2,1)], bandwidth = plot_settings$bw_smoothScatter)
        contour(
          y = con$x2,
          x = con$x1,
          z = con$fhat,
          add = TRUE,
          labcex = 0.75 * plot_settings$cex,
          col = plot_settings$col_contour,
          nlevels = plot_settings$nlevels
        )

        ##add rug
        if(xrug)
          rug(x = data[,2], side = 3, col = rgb(0,0,0,0.3))

        if(yrug)
          rug(x = data[,1], side = 2, col = rgb(0,0,0,0.3))


        ##add x-axis above
        if(xaxt){
          at <- pretty(data[,2], n = plot_settings$pscales)
          at <- at[-c(1,length(at))]
          axis(side = 3, at = at, labels = NULL)

        }

        ##add y-axis above
        if(yaxt){
          at <- pretty(data[,1], n = plot_settings$pscales)
          at <- at[-c(1,length(at))]
          axis(side = 2, at = at, labels = NULL)

        }

      }

      ###PLOT
      ##set par
      par(mfrow = c(n,n), mar = c(0,0,0,0), oma = c(4,4,3,3), cex = plot_settings$cex)

      ##now we have to create all the plots and then decide what
      ##needs to be plotted when
      ##set plot counter
      p <- 1

      ##START LOOP
      for(i in 1:n^2){
        ##(A) plot empty plots
        if(i %in% m_upper)
          empty_plot()

        ##(B) plot diagonale plots
        if(i %in% m_diag){

          ##do not plot density for the first and the last, otherwise it looks odd
          if(i %in% m_diag[1]){
            name_plot(data = data_list[[p]], name = name[i], ydens = FALSE)

          }else if(i %in% m_diag[length(m_diag)]){
            name_plot(data = data_list[[p]], name = name[i], xdens = FALSE)

          }else{
            name_plot(data = data_list[[p]], name = name[i])

          }


        }


        ##(C) plot scatter plot
        ## (here we have to decide whether the axis is plotted or not)
        if(i %in% m_lower){
          if(i %in% m_diag_sub){
           if(plot_settings$rug){
            xaxt = TRUE
            yaxt = TRUE
            xrug = TRUE
            yrug = TRUE

           }else{
             xaxt = FALSE
             yaxt = FALSE
             xrug = FALSE
             yrug = FALSE

           }

          }else{
            xaxt = FALSE
            yaxt = FALSE
            xrug = FALSE
            yrug = FALSE

          }

          ##plot
          scatter_plot(
            data = data_list[[p]],
            xaxt = xaxt,
            yaxt = yaxt,
            xrug = xrug,
            yrug = yrug
          )

          ##update counter
          p <- p + 1

        }

      } #end loop for plotting

      ##ADD MTEXT
      ##add axis labelling
      mtext(plot_settings$xlab, side = 1, outer = TRUE, line = 1,cex = 0.95 * plot_settings$cex)
      mtext(plot_settings$ylab, side = 2, outer = TRUE, line = 1,cex = 0.95 * plot_settings$cex)

      ##add main
      mtext(plot_settings$main, side = 3, outer = TRUE, line = 1, cex = 1.1 * plot_settings$cex)

  }

}

#TODO
#'Old function ScatterPlots()
#'@rdname plot_Scatterplots
#'@md
#'@export
ScatterSamples <- function(...){
  .Defunct(
    new = "plot_Scatterplots()",
    package = "BayLum"
  )

}
