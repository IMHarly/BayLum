#' Bayesian analysis for the OSL age estimation of various samples
#'
#' This function computes the age of at least two samples according to the model developed in Combes and Philippe (2017),
#' based on outputs of \code{\link{Generate_DataFile}} or \code{\link{Generate_DataFile_MG}}
#' or both of them using \code{\link{Concat_DataFile}}.\cr
#' Samples, for which data is avalilable in several BIN files, can be analysed.\cr
#' Single-grain or Multi-grain OSL measurements can be analysed simultaneouly.
#'
#' @param DATA list of objects: LT, sLT, ITimes, dLab, ddot_env, regDose, J, K, Nb_measurement,
#' provided by the function \code{\link{Generate_DataFile}} or \code{\link{Generate_DataFile_MG}} or \code{\link{Concat_DataFile}}.
#' \code{DATA} contains information for more than one sample.
#' @param SampleNames character vector: names of sample. The length of this vector is equal to \code{Nb_sample}.
#' @param Nb_sample integer : number of samples, \code{Nb_sampe>1}.
#' @param BinPerSample integer vector (with default): vector with the number of BIN files per sample.
#' The length of this vector is equal to \code{Nb_sample}.
#' \code{BinPerSample}[i] correponds to the number of BIN files for the sample whose number ID is equal to \code{i}.
#' For more information to fill this vector, we refer to detatils in \code{\link{Generate_DataFile}} or in \code{\link{Generate_DataFile_MG}}.
#' @param SavePdf boolean (with default): if TRUE save graphs in pdf file named \code{OutputFileName} in folder \code{OutputFilePath}.
#' @param OutputFileName character (with default): name of the pdf file that will be generated by the function if \code{SavePdf}=TRUE.
#' @param OutputFilePath character (with default): path to the pdf file that will be generated by the function if \code{SavePdf}=TRUE.
#' @param SaveEstimates boolean (with default): if TRUE save Bayes estimates, confidence interval at level 68\% and 95\% and ,
#' in a csv table named \code{OutputFileName} in folder \code{OutputFilePath}.
#' @param OutputTableName character (with default): name of the table that will be generated by the function if \code{SaveEstimates}=TRUE.
#' @param OutputTablePath character (with default): path to the table that will be generated by the function if \code{SaveEstimates}=TRUE.
#' @param THETA numeric matrix or character (with default): input object for systematic and individual error.
#' If systematic errors are considered, see the details section for instructions regarding how to correctly fill \code{THETA}.
#' Otherwise, default value is suitable, and only individual error is considered.
#' @param sepTHETA character (with default): if \code{THETA} is character,
#' indicate column separator in \code{THETA} .csv file.
#' @param PriorAge numeric vector (with default): lower and upper bounds for age parameter of each sample.
#'  \code{length(PriorAge)=2*Nb_sample}
#'  and \code{PriorAge[2i-1,2i]} correponds to the lower and upper bounds of sample whose number ID is equal to \code{i}.
#' @param StratiConstraints numeric matrix or character(with default): input object for the statigraphic relation between samples.
#' If there is stratigraphic relation between samples see the details section for instructions regarding how to correctly fill \code{StratiConstraints}.
#' Otherwise, default value is suitable.
#' @param sepSC character (with default): if \code{StratiConstraints} is character,
#' indicate column separator in \code{StratiConstraints} .csv file.
#' @param LIN_fit logical (with default): if TRUE (default) allows a linear component,
#' on top of the (default) saturating exponential curve, for the fitting of dose response curves.
#' Please see details for more informations on the proposed dose response curves.
#' @param Origin_fit logical (with default): if TRUE, forces the dose response curves to pass through the origin.
#' Please see details for more informations on the proposed growth curves.
#' @param distribution character (with default): type of distribution that defines
#' how individual equivalent dose values are distributed around the palaeodose.
#' Allowed inputs are \bold{"cauchy"}, \bold{"gaussian"}, \bold{"lognormal_A"} and \bold{"lognormal_M"}.
#' @param Taille integer (with default): number of iterations for the MCMC computation (for more information see \code{\link{jags.model}}).
#' @param t integer (with default): 1 every \code{t} iterations of the MCMC is considered for sampling the posterior distribution
#' (for more information see \code{\link{jags.model}}).
#' @param Nb_chaines integer (with default): number of independent chains for the model (for more information see \code{\link{jags.model}}).
#'
#' @details
#' \bold{** How to fill} \code{StratiConstraints} \bold{? **}
#'
#' If there is stratigraphic relations between samples, \bold{information in DATA must be ordered by order of increasing ages}.
#' To do this the user can either fill right \code{Names} in \code{\link{Generate_DataFile}} or in \code{\link{Generate_DataFile_MG}}
#' (as it is indicated in Details section of these function), or ordered by order of increasing ages
#' outputs of \code{\link{Generate_DataFile}} or \code{\link{Generate_DataFile_MG}} in \code{\link{Concat_DataFile}}.
#'
#' The user can fill the \code{StratiConstraints} matrix as follow.\cr
#' \enumerate{
#'  \item \bold{Size of the matrix}: row number of \code{StratiConstraints} matrix is equal to \code{Nb_sample+1},
#' and column number is equal to \code{Nb_sample}. \cr
#'  \item \bold{First line of the matrix}:
#' for all \code{i in {1,...,Nb_Sample}}, \code{StratiConstraints[1,i]=1} that means the lower bound of the sample age (given in \code{PriorAge[2i-1]})
#' for the sample whose number ID is equal to \code{i}, is taken into account.\cr
#'  \item \bold{Sample relations}: for all  \code{j in {2,...,Nb_Sample+1}} and all \code{i in {j,...,Nb_Sample}},
#' \code{StratiConstraints[j,i]=1} if sample age whose number ID is equal to \code{j-1} is lower than sample age whose number ID is equal to \code{i}.
#' Otherwise, \code{StratiConstraints[j,i]=0}.
#' }
#' Note that \code{StratiConstraints_{2:Nb_sample+A,1:Nb_sample}} is a upper triangular matrix.
#'
#'
#' The user can also use \code{\link{SCMatrix}} function to construc the \code{StratiConstraints} matrix.
#'
#' The user can also refer to a .csv file that containts the relation between samples as defined above.
#'
#' \bold{** How to fill} \code{THETA} \bold{covariance matrix concerning common and individual error? **}
#'
#' If systematic errors are considered, the user can fill the \code{THETA} matrix as follow.\cr
#' \itemize{
#'  \item row number of \code{THETA} is equal the column number, equal to \code{Nb_sample}.
#'  \item For all \code{i in {1,...,Nb_sample}}, \code{THETA[i,i]} containts individual error
#'  plus systematic error of the sample whose number ID is equal to \code{i}.
#'  \item For all \code{i,j in {1,...,Nb_sample}} and \code{i} different from \code{j} ,
#' \code{THETA[i,j]} containts common error between samples whose number ID are equal to \code{i} and \code{j}.
#' }
#' Note that \code{THETA[i,j]} is a symetric matrix.
#'
#' The user can also refer to a .csv file that containts the errors as defined above.\cr
#'
#' \bold{** Option on growth curves **}
#'
#' As for \code{\link{Age_Computation}} and \code{\link{Palaeodose_Computation}}, the user can choose from 4 dose response curves:
#' \itemize{
#'   \item \bold{Saturating exponential plus linear growth} (\code{AgesMultiCS2_EXPLIN}):
#'
#'   for all \code{x} in IR+, \code{f(x)=a(1-exp(-x/b))+cx+d}; select
#'   \itemize{
#'     \item \code{LIN_fit=TRUE}
#'     \item \code{Origin_fit=FALSE}
#'   }
#'   \item \bold{Saturating exponential growth} (\code{AgesMultiCS2_EXP}):
#'
#'   for all \code{x} in IR+, \code{f(x)=a(1-exp(-x/b))+d}; select
#'   \itemize{
#'     \item \code{LIN_fit=FALSE}
#'     \item \code{Origin_fit=FALSE}
#'   }
#'   \item \bold{Saturating exponential plus linear growth and fitting through the origin} (\code{AgesMultiCS2_EXPLINZO}):
#'
#'   for all \code{x} in IR+, \code{f(x)=a(1-exp(-x/b))+cx}; select
#'   \itemize{
#'     \item \code{LIN_fit=TRUE}
#'     \item \code{Origin_fit=TRUE}
#'   }
#'   \item \bold{Saturating exponential growth and fitting through the origin} (\code{AgesMultiCS2_EXPZO}):
#'
#'   for all \code{x} in IR+, \code{f(x)=a(1-exp(-x/b))}; select
#'   \itemize{
#'     \item \code{LIN_fit=FALSE}
#'     \item \code{Origin_fit=TRUE}
#'   }
#' }
#'
#' \bold{** Option on equivalent dose distribution around the palaeodose **}
#'
#' The use can choose between :
#' \itemize{
#'   \item \code{cauchy}: a Cauchy distribution with location parameter equal to the palaeodose of the sample
#'   \item \code{gaussian}: a Gaussian distribution with mean equal to the palaeodose of the sample
#'   \item \code{lognormal_A}: a log-normal distribution with mean or \bold{A}verage equal to the palaeodose of the sample
#'   \item \code{lognormal_M}: a log-normal distribution with \bold{M}edian equal to the palaeodose of the sample
#' }
#'
#' @return
#' \bold{NUMERICAL OUTPUT}\cr
#'
#' \enumerate{
#' \item \bold{A list containing the following objects:}
#'  \itemize{
#'   \item \bold{Sampling}: that corresponds to a sample of the posterior distributions
#'  of the Age, palaeodose and equivalent dose dispersion parameters.
#'   \item \bold{Model_GrowthCurve}, stating which dose response fitting option was chosen;
#'   \item \bold{Distribution}, stating which distribution was chosen to model the dispersion of
#'  individual equivalent dose values around the palaeodose of the sample;
#'   \item \bold{PriorAge}, stating the priors used for the age parameter.
#'  }
#'  \item\bold{The Gelman and Rudin test of convergency}: prints the result of the Gelman and Rudin test of convergency for the age, palaeodose and equivalent dose dispersion parameters for each sample.
#' A result close to one is expected.\cr
#' In addition, the user must visually assess the convergency of the trajectories by looking at the graph
#' generated by the function (see 2- for more informations).\cr
#' If both convergencies (Gelman and Rudin test and plot checking) are satisfactory,
#' the user can consider the estimates as valid. Otherwise, the user may try increasing the number of MCMC interations
#' (\code{Taille}) to reach convergency.
#'   \item \bold{Credible intervals and Bayes estimates}: prints the Bayes esitmates, the credible intervals at 95\% and 68\% for
#' the age, palaeodose and equivalent dose dispersion parameters for each sample.
#' }
#'
#' \bold{PLOT OUTPUT}
#'
#' \enumerate{
#'  \item\bold{MCMC trajectories}: A graph with the MCMC trajectories and posterior distributions of the age, palaeodose and equivalent dose dispersion parameters
#' is displayed, there is one page per sample. \cr
#' The first line of the figure correponds to the age parameter, the second to the palaeodose parameter
#' and the third to the equivalent dose dispersion parameter.
#' On each line, the plot on the left represents the MCMC trajectories, and the one on the right the posterior distribution of the parameter.
#'  \item \bold{Summary of sample age estimates}: plot credible intervals and Bayes estimate of each sample age on a same graph.
#'  \item\bold{Matrix of scatterplots}: the \code{i},\code{j} th scatterplot contains sample of the posterior distribution of the sample ID \code{i} plotted
#'  against the one of the sample ID \code{j}.
#' }
#'
#' @author Claire Christophe, Guillaume Guerin
#'
#' @seealso
#' \code{\link{Generate_DataFile}}, \code{\link{Generate_DataFile_MG}},
#' \code{\link{rjags}}, \code{\link{MCMC_plot}}, \code{\link{SCMatrix}}
#' \code{\link{Age_Computation}}, \code{\link{Palaeodose_Computation}}
#'
#' @references
#' Combes, Benoit and Philippe, Anne, 2017.
#' Bayesian analysis of multiplicative Gaussian error for multiple ages estimation in optically stimulated luminescence dating.
#' Quaternary Geochronology (39, 24-34)
#'
#' Combes, B., Philippe, A., Lanos, P., Mercier, N., Tribolo, C., Guerin, G., Guibert, P., Lahaye, C., 2015.
#' A Bayesian central equivalent dose model for optically stimulated luminescence dating.
#' Quaternary Geochronology 28, 62-70. doi:10.1016/j.quageo.2015.04.001
#'
#' @examples
#' ## Load data
#' # data(DATA1,envir = environment())
#' # data(DATA2,envir = environment())
#' # DATA=Concat_DataFile(DATA2,DATA1)
#'
#' ## Age computation of samples GDB5 and GDB3,
#' ## without common error and without stratigraphic constraints
#' # Age=AgeS_Computation(DATA,Nb_sample=2,SampleNames=c("GDB5","GDB3"),Taille=10000)
#'
#' ## Age computation of samples GDB5 and GDB3,
#' ## without common error, assuming GDB5 age younder than GDB3 age
#' # (SC=matrix(data=c(1,1,0,1,0,0),ncol=Nb_sample,nrow = (Nb_sample+1),byrow = T))
#' # Age=AgeS_Computation(DATA,Nb_sample=2,SampleNames=c("GDB5","GDB3"),
#' #    StratiConstraints=SC,Taille=10000)
#'
#' @export

AgeS_Computation<-function(DATA,SampleNames,Nb_sample,
                           BinPerSample=rep(1,Nb_sample),
                           SavePdf=FALSE,OutputFileName=c('MCMCplot',"summary","2per2Laws"),OutputFilePath=c(""),
                           SaveEstimates=FALSE,OutputTableName=c("DATA"),OutputTablePath=c(''),
                           THETA=c(),sepTHETA=c(','),
                           PriorAge=rep(c(0.01,100),Nb_sample),
                           StratiConstraints=c(),sepSC=c(','),
                           LIN_fit = TRUE,Origin_fit = FALSE,
                           distribution=c("cauchy"),
                           Taille=50000,t=5,Nb_chaines=3){

  #--Index preparation
  CSBinPerSample=cumsum(BinPerSample)
  LengthSample=c()
  for(ns in 1:Nb_sample){
    LengthSample=c(LengthSample,length(DATA$LT[[ns]][,1]))
  }
  CSLengthSample=c()
  CSLengthSample=c(0,cumsum(LengthSample))
  index2=c(0,cumsum(DATA$J))

  #--- File preparation
  LT=matrix(data=0,nrow=sum(DATA$J),ncol=(max(DATA$K)+1))
  sLT=matrix(data=0,nrow=sum(DATA$J),ncol=(max(DATA$K)+1))
  IrrT=matrix(data=0,nrow=sum(DATA$J),ncol=(max(DATA$K)))
  for(ns in 1:Nb_sample){
    LT[seq(CSLengthSample[ns]+1,CSLengthSample[ns+1],1),1:length(DATA$LT[[ns]][1,])]<-DATA$LT[[ns]]
    sLT[seq(CSLengthSample[ns]+1,CSLengthSample[ns+1],1),1:length(DATA$sLT[[ns]][1,])]<-DATA$sLT[[ns]]
    IrrT[seq(CSLengthSample[ns]+1,CSLengthSample[ns+1],1),1:length(DATA$ITimes[[ns]][1,])]<-DATA$ITimes[[ns]]
  }

  #--- THETA matrix
  if(length(THETA[,1])==0){
    THETA=diag(DATA$ddot_env[2,CSBinPerSample]+(DATA$ddot_env[1,CSBinPerSample])^2*DATA$dLab[2,CSBinPerSample])
  }else{
    if(is(THETA)[1]=="character"){
      errorMatrix=read.csv(THETA,sep=sepTHETA)
      THETA=as.matrix(errorMatrix)
    }
  }

  #--- StratiConstraints matrix
  if(length(StratiConstraints)==0){
    StratiConstraints=matrix(data=c(rep(1,Nb_sample),rep(0,Nb_sample*Nb_sample)),ncol=Nb_sample,nrow = (Nb_sample+1),byrow = T)
  }else{
    if(is(StratiConstraints)[1]=="character"){
      SCMatrix=read.csv(StratiConstraints,sep=sepSC)
      StratiConstraints=as.matrix(SCMatrix)
    }
  }

  #--- BUG file selection
  Model_AgeS<-0
  data(Model_AgeS,envir = environment())

  if(LIN_fit==TRUE){
    cLIN=c('LIN')
  }else{cLIN=c()}
  if(Origin_fit==TRUE){
    cO=c("ZO")
  }else{cO=c()}
  Model_GrowthCurve=c(paste("AgesMultiCS2_EXP",cLIN,cO,sep=""))

  #--- JAGS run
  dataList = list('N'= LT,'sN'=sLT,"IT"=IrrT,
                  "sDlab"=DATA$dLab[1,],
                  'J'=DATA$J,
                  'K'=DATA$K,
                  "I"=Nb_sample,
                  "ddot"=DATA$ddot_env[1,CSBinPerSample],
                  "Gamma"=THETA,
                  "xbound"=PriorAge,
                  "StratiConstraints"=StratiConstraints,
                  "index"=index2,
                  "BinPerSample"=BinPerSample,
                  "CSBinPerSample"=CSBinPerSample)
  jags <- jags.model(textConnection(Model_AgeS[[Model_GrowthCurve]][[distribution]]), data = dataList, n.chains = Nb_chaines, n.adapt=Taille)
  update(jags,Taille)
  echantillon = coda.samples(jags,c("A","D","sD"),min(Taille,10000),thin=t)

  sample=echantillon[[1]]
  for(i in 2:Nb_chaines){
    sample=rbind(sample,echantillon[[i]])
  }

  if(SavePdf==TRUE){
    pdf(file=paste(OutputFilePath,OutputFileName[1],".pdf",sep=""),width=8,height=10)
  }
  MCMC_plot(sample,
            length(echantillon[[1]][,1]),
            SampleNames=SampleNames,
            Nb_sample=Nb_sample,
            Nb_chaines=Nb_chaines,
            value=c(0,Nb_sample,2*Nb_sample))
  if(SavePdf==TRUE){
    dev.off()
  }
  ##--- Graphical interpretation, and print result

  ##- Gelman and rudin test of convergency of the MCMC
  CV=gelman.diag(echantillon,multivariate=FALSE)
  cat(paste("\n\n>> Convergencies of MCMC of Age parameter <<\n"))
  for(i in 1:Nb_sample){
    cat("----------------------------------------------\n")
    cat(paste(" Sample name: ", SampleNames[i],"\n"))
    cat("---------------------\n")
    cat(paste("\t\t", "Bayes estimate ", "Uppers confidence interval\n"))
    cat(paste(paste("A_",SampleNames[i],sep=""),"\t",round(CV$psrf[i,1],2),"\t\t",round(CV$psrf[i,2],2),"\n"))
    cat(paste(paste("D_",SampleNames[i],sep=""),"\t",round(CV$psrf[(Nb_sample+i),1],2),"\t\t",round(CV$psrf[(Nb_sample+i),2],2),"\n"))
    cat(paste(paste("sD_",SampleNames[i],sep=""),"\t",round(CV$psrf[(2*Nb_sample+i),1],2),"\t\t",round(CV$psrf[(2*Nb_sample+i),2],2),"\n"))
  }

  cat("\n\n________________________________________________________________________________\n")
  cat(" *** WARNING: following informations are only valid if MCMC chains converged  ***\n")
  cat("________________________________________________________________________________\n")

  # Matrix of results
  rnames=c()
  for(i in 1:Nb_sample){
    rnames=c(rnames,paste("A_",SampleNames[i],sep=""),paste("D_",SampleNames[i],sep=""),paste("sD_",SampleNames[i],sep=""))
  }
  R=matrix(data=NA,ncol=8,nrow=3*Nb_sample,
           dimnames=list(rnames,c("lower bound at 95%","lower bound at 68%","Bayes estimate","upper bound at 68%","upper bound at 95%","","Convergencies: Bayes estimate","Convergencies: uppers confidence interval")))

  ##- Bayes estimate and confidential interval
  cat(paste("\n\n>> Bayes estimates of Age, Palaeodose and its dispersion for each sample and confidence interval <<\n"))
  AgePlot95=matrix(data=NA,nrow=Nb_sample,ncol=3)
  AgePlot68=matrix(data=NA,nrow=Nb_sample,ncol=3)
  AgePlotMoy=rep(0,Nb_sample)
  for(i in 1:Nb_sample){
    cat("----------------------------------------------\n")
    cat(paste(" Sample name: ", SampleNames[i],"\n"))
    cat("---------------------\n")

    cat(paste("Parameter", "\t","Bayes estimate","\t"," Confidence interval \n"))
    cat(paste(paste(" A_",SampleNames[i],sep=""),"\t",round(mean(sample[,i]),3),'\n'))
    cat("\t\t\t\t\t\t lower bound \t upper bound\n")
    HPD_95=CredibleInterval(sample[,i],0.95)
    HPD_68=CredibleInterval(sample[,i],0.68)
    cat("\t\t\t\t at level 95% \t",round(c(HPD_95[2]),2),"\t\t",round(c(HPD_95[3]),2),"\n")
    cat("\t\t\t\t at level 68% \t",round(c(HPD_68[2]),2),"\t\t",round(c(HPD_68[3]),2),"\n")
    AgePlot95[i,]=HPD_95
    AgePlot68[i,]=HPD_68
    AgePlotMoy[i]=round(mean(sample[,i]),3)

    R[(3*(i-1)+1),3]=round(mean(sample[,i]),3)
    R[(3*(i-1)+1),c(1,5)]=round(HPD_95[2:3],3)
    R[(3*(i-1)+1),c(2,4)]=round(HPD_68[2:3],3)

    cat(paste("\nParameter", "\t","Bayes estimate","\t"," Confidence interval \n"))
    cat(paste(paste(" D_",SampleNames[i],sep=""),"\t",round(mean(sample[,(Nb_sample+i)]),3),'\n'))
    cat("\t\t\t\t\t\t lower bound \t upper bound\n")
    HPD_95=CredibleInterval(sample[,(Nb_sample+i)],0.95)
    HPD_68=CredibleInterval(sample[,(Nb_sample+i)],0.68)
    cat("\t\t\t\t at level 95% \t",round(c(HPD_95[2]),2),"\t\t",round(c(HPD_95[3]),2),"\n")
    cat("\t\t\t\t at level 68% \t",round(c(HPD_68[2]),2),"\t\t",round(c(HPD_68[3]),2),"\n")

    R[(3*(i-1)+2),3]=round(mean(sample[,(Nb_sample+i)]),3)
    R[(3*(i-1)+2),c(1,5)]=round(HPD_95[2:3],3)
    R[(3*(i-1)+2),c(2,4)]=round(HPD_68[2:3],3)

    cat(paste("\nParameter", "\t","Bayes estimate","\t"," Confidence interval \n"))
    cat(paste(paste("sD_",SampleNames[i],sep=""),"\t",round(mean(sample[,(2*Nb_sample+i)]),3),'\n'))
    cat("\t\t\t\t\t\t lower bound \t upper bound\n")
    HPD_95=CredibleInterval(echantillon[[1]][,(2*Nb_sample+i)],0.95)
    HPD_68=CredibleInterval(echantillon[[1]][,(2*Nb_sample+i)],0.68)
    cat("\t\t\t\t at level 95% \t",round(c(HPD_95[2]),2),"\t\t",round(c(HPD_95[3]),2),"\n")
    cat("\t\t\t\t at level 68% \t",round(c(HPD_68[2]),2),"\t\t",round(c(HPD_68[3]),2),"\n")

    R[(3*(i-1)+3),3]=round(mean(sample[,(2*Nb_sample+i)]),3)
    R[(3*(i-1)+3),c(1,5)]=round(HPD_95[2:3],3)
    R[(3*(i-1)+3),c(2,4)]=round(HPD_68[2:3],3)

    R[(3*(i-1)+1):(3*i),6]=c('','','')
    R[(3*(i-1)+1):(3*i),7]=round(CV$psrf[c(i,i+Nb_sample,i+2*Nb_sample),1],2)
    R[(3*(i-1)+1):(3*i),8]=round(CV$psrf[c(i,i+Nb_sample,i+2*Nb_sample),2],2)

  }
  cat("\n----------------------------------------------\n")

  #- graphical representation
  if(SavePdf==TRUE){
    pdf(file=paste(OutputFilePath,OutputFileName[2],".pdf",sep=""))
  }
  par(mfrow=c(1,1),las = 1,oma=c(3,5,1,0.5))
  plot(c(AgePlot95[1,2:3]),c(Nb_sample,Nb_sample),
       ylim=c(0.5,Nb_sample+1),xlim=c((min(AgePlot95[,2])-1),(max(AgePlot95[,3])+1)),
       type="l",lwd=5,yaxt="n",xlab="Age (ka)",ylab="",cex.lab=1.5,col="midnightblue",
       main="Ages of samples",cex.main=2)
  grid(ny=NA, lwd = 3)
  lines(c(AgePlot68[1,2:3]),c(Nb_sample,Nb_sample),col="darkslategray3",lwd=5)
  lines(AgePlotMoy[1],Nb_sample,col="firebrick",lwd=5,type='o')
  uu=seq(Nb_sample,1,-1)
  axis(2,uu,labels=SampleNames,cex.axis=1.5)
  legend(min(AgePlot95[,3]),Nb_sample+1,c("Bayes estimator","HPD at level 68% ","HPD at level 95%"),
         pch=c(1,NA,NA),lty=c(NA,1,1),lwd=c(5,5,5),col=c("firebrick","darkslategray3","midnightblue"),bty="o")
  for(i in 2:Nb_sample){
    lines(c(AgePlot95[i,2:3]),c(Nb_sample-(i-1),Nb_sample-(i-1)),lwd=5,col="midnightblue")
    lines(c(AgePlot68[i,2:3]),c(Nb_sample-(i-1),Nb_sample-(i-1)),lwd=5,col='darkslategray3')
    lines(AgePlotMoy[i],(Nb_sample-(i-1)),col="firebrick",lwd=5,type="o")
  }
  if(SavePdf==TRUE){
    dev.off()
  }

  # check if there is stratigraphic order between sample.
  #if(sum(StratiConstraints[2:Nb_sample,1:Nb_sample]>0)){
    if(SavePdf==TRUE){
      pdf(file=paste(OutputFilePath,OutputFileName[3],".pdf",sep=""))
    }
    pairs(sample[,c(1:Nb_sample)],cex=0.2, labels=SampleNames)
    if(SavePdf==TRUE){
      dev.off()
    }
  #}

  if(SaveEstimates==TRUE){
    write.csv(R,file=c(paste(OutputTablePath,"Estimates",OutputTableName,".csv",sep="")))
  }

  Info=list("Sampling"=echantillon,"Model_GrowthCurve"=Model_GrowthCurve, "Distribution"=distribution,"PriorAge"=PriorAge)
  return(Info)

}
