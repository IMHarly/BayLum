#' Plot MCMC trajectories and posterior distributions
#'
#' This function uses the output of [rjags::jags.model] to visualise the traces of the MCMC and the
#' corresponding densities. In particular it displays the posterior distributions of the age, if it is calculated,
#' palaeodose and the equivalent dose dispersion parameters of the sample. The function output is very
#' similar to plot output produced with the 'coda' package, but tailored to meet the needs in
#' the context of the 'BayLum' package.
#'
#' The function is used in the function \code{\link{Age_Computation}}, \code{\link{AgeS_Computation}}
#' and \code{\link{Palaeodose_Computation}}, but can be used also as standalone plot function.
#'
#' @param object [coda::mcmc.list] or [coda::mcmc] (**required**): Output generated by [rjags::jags.model],
#' e.g., in \code{\link{Age_Computation}}
#'
#' @param axes_labels [character] (with default): Axes labels used for the trace and density plots. The labels should
#' be provided as names [character] [vector] with the parameter names as the names used to asign the axes labelling.
#' The labelling for the xaxis (trace plots) and yaxis (density plot) cannot be modified.
#'
#' @param plot_single [logical] (with default): Enables/disables the single plot mode of the function, i.e.
#' if set to `TRUE` every plot is returned in a single plot and own [par] settings can be applied.
#'
#' @param n.chains [numeric] (optional): Set the number of chains to visualise, if nothing is provided the
#' number of chains is determined from the input object
#'
#' @param n.iter [numeric] (with default): Set the number of iterations to be visualised in the trace plots.
#'
#' @param smooth [logical] (with default): Enable/disables smooth of trace plots using [stats::smooth]
#'
#' @param ... further arguments that can be passed to modifiy the plot output. Supported arguments are
#' `lwd`, `lty`, `col`, `type`, `cex`,`mtext`, cf. [mtext] for `mtext` and [plot.default] for the other
#' arguments.
#'
#'
#' @return
#' Two plots: Traces of the MCMC chains and the corresponding density plots. This plots
#' are similar to [coda::traceplot] and [coda::densplot].
#'
#' @section Function version: 0.1.0
#'
#' @keywords dplot
#'
#' @author Sebastian Kreutzer, IRAMAT-CRP2A, Universit√© Bordeaux Montaigne (France). This function
#' is a re-written version of the function `MCMC_plot()` by Claire Christophe
#'
#' @seealso \code{\link{Age_Computation}}, \code{\link{AgeS_Computation}}, \code{\link{Palaeodose_Computation}},
#'  \code{\link{coda.samples}} and \code{\link{rjags}} packages.
#'
#' @examples
#' data(MCMCsample,envir = environment())
#' object <- coda::as.mcmc(MCMCsample)
#' plot_MCMC(object)
#'
#' @md
#' @export
plot_MCMC <- function(
  object,
  axes_labels = c("A" = "Age (ka)", "D" = "D (Gy)", "sD" = "sD (Gy)"),
  n.chains = NULL,
  n.iter = 1000,
  smooth = FALSE,
  plot_single = FALSE,
  ...
){

  # Integrity tests ---------------------------------------------------------------------------
  if(class(object) != "mcmc.list"){
    if(class(object) == "mcmc"){
      object <- coda::as.mcmc.list(object)

    }else{
      stop("[plot_MCMC()] 'sample' has to be of class 'mcmc.list' or 'mcmc'!", call. = FALSE)

    }

  }


  # Plot preparation ----------------------------------------------------------------------------
  ##set number of chains ... why we are doing it here and not in the argument?
  ##We first have to evalulate the object to make sure that it is of type 'mcmc.list'
  if(is.null(n.chains))
    n.chains <- coda::nchain(object)

  ##treat the argument n.iter, which is rather fragile and easly misused
  if(length(n.iter) == 1 && n.iter < coda::niter(object))
    n.iter <- floor(seq(1,coda::niter(object), length.out = abs(n.iter)))

  if(length(n.iter) > coda::niter(object) || max(n.iter) > coda::niter(object) || min(n.iter) < 1 || length(n.iter) < 2){
    warning("[plot_MCMC()] 'n.iter' out of range, reset to default!", call. = FALSE, immediate. = TRUE)
    n.iter <- floor(seq(1,coda::niter(object), length.out = 1000))

      if(length(n.iter) > coda::niter(object))
        n.iter <- 1:coda::niter(object)

    }

  ##set plot defaults
  plot_settings <- list(
    mtext = "",
    cex = 1,
    type = "l",
    col = 1:n.chains,
    lty = 1:n.chains,
    lwd = 1

  )

  ##modify on request
  plot_settings <- modifyList(x = plot_settings, val = list(...))

  ##prepare the plot object, this needs to be done manually, due to special requests

    ##(1) trace plots
    ##extract all chain for each variable and combine them in list of matrices
    traces_list <- lapply(coda::varnames(object), function(v){
      vapply(1:n.chains, function(x){
        if(smooth){
          smooth(as.numeric((object[[x]][,v]))[n.iter])

        }else{
          as.numeric((object[[x]][,v]))[n.iter]

        }

      }, numeric(length(n.iter)))

    })

    ##re-assign var names to list
    names(traces_list) <- coda::varnames(object)

    ##create a list of ylab for the traces using a lookup table
    ##if something is not yet in our lookup table it will produce NA
    ylab_traces <- as.character(axes_labels[coda::varnames(object)])

    ##(2) density plots
    density_list <- lapply(traces_list, function(v){
      temp <- matrix(unlist(lapply(1:ncol(v), function(x){
        density(v[,x])$y

      })), ncol = n.chains)

      ##add first column, we gonna need it later
      cbind(density(v[,1])$x, temp)
    })

    ##the trace plot ylab becomes the density xlab
    xlab_density <- ylab_traces

  # Plotting ------------------------------------------------------------------------------------

  ##make sure that we reset the plotting parameters on exit
  par.default <- par()$mfrow
  on.exit(par(mfrow = par.default))

  ##set mfrow if not single plot is wanted
  if(!plot_single)
    par(mfrow = c(coda::nvar(object), 2))

  ##plot traces
  for(v in 1:coda::nvar(object)){
    ##traces
    matplot(
      y = traces_list[[v]],
      type = plot_settings$type,
      lty = plot_settings$lty,
      lwd = plot_settings$lwd,
      col = plot_settings$col,
      xlab = "Iterations",
      ylab = ylab_traces[v],
      main = coda::varnames(object)[v],
      cex = plot_settings$cex
    )
    mtext(side = 3, plot_settings$mtext, cex = plot_settings$cex * 0.8)

    ##density
    matplot(
      x = density_list[[v]][, 1],
      y = density_list[[v]][, 2:(n.chains + 1)],
      type = plot_settings$type,
      lty = plot_settings$lty,
      lwd = plot_settings$lwd,
      col = plot_settings$col,
      ylab = "Density",
      xlab = xlab_density[v],
      main = coda::varnames(object)[v],
      cex = plot_settings$cex
    )
    mtext(side = 3, plot_settings$mtext, cex = plot_settings$cex * 0.8)

  }

}
